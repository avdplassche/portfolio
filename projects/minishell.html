<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alexandre | Minishell</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Load Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600;700&family=Montserrat:wght@400;600;700;800&display=swap" rel="stylesheet">

    <!-- Custom Style Block for Dark Theme and Typography -->
    <style>
:root {
            --color-bg: #1A1A1A; /* Dark Charcoal Background */
            --color-text: #F0F0F0; /* Off-White Text */
            --color-accent: #06B6D4; /* Cyan Accent */
        }

        body {
			background-image: url("../images/background_gradient_05.png");
			background-repeat: no-repeat;
			background-size: cover;
			background-position: center;
			background-attachment: fixed;
            font-family: 'IBM Plex Mono', monospace;
            /*background-color: var(--color-bg);*/
            color: var(--color-text);
            scroll-behavior: smooth;
        }

        .hero-title {
            font-family: 'Montserrat', sans-serif;
        }

        /* Styling for the large project content sections */
        .content-section p {
            line-height: 1.75;
            margin-bottom: 1.5rem;
            color: #ccc;
        }

        pre {
            white-space: pre-wrap;
            word-break: break-all;
        }

        /* Highlight styling for the command examples */
        .command-box {
            background-color: #2D3748; /* Darker background for the blocks */
            border-left: 4px solid var(--color-accent);
            padding: 1rem;
            margin-bottom: 1.5rem;
            overflow-x: auto;
        }
    </style>
</head>
<body class="min-h-screen">

    <!-- NAVIGATION BAR -->
    <header class="sticky top-0 z-50 bg-[#1A1A1A] bg-opacity-90 backdrop-blur-sm shadow-xl">
        <nav class="max-w-6xl mx-auto px-4 py-6 flex justify-center items-center">
            <div class="flex space-x-4 text-lg font-medium">
                <!-- Links updated to reference relative paths -->
                <a href="../index.html" class="text-gray-400 hover:text-white transition duration-200">home</a>
                <span class="text-gray-600">/</span>
                <a href="../work.html" class="text-white transition duration-200" style="color:var(--color-accent);">work</a>
                <span class="text-gray-600">/</span>
                <a href="../cv.html" class="text-gray-400 hover:text-white transition duration-200">cv</a>
                <span class="text-gray-600">/</span>
                <a href="../contact.html" class="text-gray-400 hover:text-white transition duration-200">contact</a>
            </div>
        </nav>
    </header>

    <main class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 pt-16 pb-20 content-section">

        <!-- HEADER AND LINKS -->
        <div class="mb-12 border-b border-gray-700 pb-8">
            <!-- Link updated to reference relative paths -->
            <a href="../work.html" class="text-sm text-gray-400 hover:text-blue-300 transition duration-200 mb-2 inline-block">&lt; Back to Projects</a>

            <!-- Project Title -->
            <h1 class="text-5xl sm:text-6xl font-extrabold text-blue-300 mb-4 hero-title">Minishell</h1>

            <!-- Project Tags -->
            <div class="flex flex-wrap gap-2">
                <span class="text-xs font-semibold px-3 py-1 bg-cyan-800 text-white rounded-full">C</span>
                <span class="text-xs font-semibold px-3 py-1 bg-cyan-800 text-white rounded-full">Shell</span>
                <span class="text-xs font-semibold px-3 py-1 bg-cyan-800 text-white rounded-full">Parsing</span>
                <span class="text-xs font-semibold px-3 py-1 bg-cyan-800 text-white rounded-full">Linux</span>
            </div>

            <!-- GitHub Link -->
            <a href="https://github.com/yourusername/minishell" target="_blank" class="mt-4 inline-block text-base font-semibold text-gray-300 hover:text-blue-300 transition duration-200 border-b border-gray-700 hover:border-cyan-400">View Source Code on GitHub</a>
        </div>

        <!-- MAIN PROJECT IMAGE/DEMO -->
        <div class="mb-12 rounded-lg overflow-hidden shadow-2xl border border-gray-700">
            <!-- Placeholder image for Minishell demonstration (Terminal look) -->
            <img src="../images/minishell_intro_04.png"
                 alt="Screenshot of the custom Minishell running commands."
                 class="w-full h-auto object-cover">
        </div>

        <!-- INTRODUCTION/DESCRIPTION (Step 1 Content) -->
        <h2 class="text-3xl font-bold text-blue-200 mb-6 hero-title">Introduction</h2>
        <p class="text-lg">
            The Minishell project is a comprehensive reimplementation of a core component of the Unix environment: the command-line interpreter (shell).
			Replicating many of the fundamental features of Bash shell, this project serves as a deep dive into system programming, demanding meticulous attention to process management, effective I/O redirection, and complex command line parsing.
        </p>
		<p>
			It was completed during the 42 common core, in collaboration with John Doe.
		</p>
		<p>
            At its core, a shell operates in a continuous execution loop, defined by three main phases:
            <br><br>
            <span class="font-bold text-blue-300">1. Waiting:</span> The shell displays a prompt and awaits user command input.
            <br>
            <span class="font-bold text-blue-300">2. Receiving:</span> The command-line input is captured as a raw string.
            <br>
            <span class="font-bold text-blue-300">3. Processing:</span> The input is then analyzed through a precise, multi-stage pipeline—from parsing to final execution—demonstrating a practical understanding of how operating systems manage user commands and processes.
        </p>

        <!-- KEY CHALLENGES/FEATURES SECTION (Outline for next steps) -->
        <h2 class="text-3xl font-bold text-blue-200 mt-16 mb-6 hero-title">Key Challenges and Features</h2>
        <p>During this project, we were asked to:</p>

        <ul class="list-disc list-inside space-y-3 pl-4 text-gray-300">
            <li class="p-2 bg-gray-800 rounded-lg border border-gray-700">Recode essential Built-in Commands (echo, cd, pwd, env, export, unset, exit).</li>
            <li class="p-2 bg-gray-800 rounded-lg border border-gray-700">Handle complex quotes and variable expansion (or why "$USER" and '$USER' behave differently).</li>
            <li class="p-2 bg-gray-800 rounded-lg border border-gray-700">Implement I/O redirections and piping to control data flow between commands.</li>
            <li class="p-2 bg-gray-800 rounded-lg border border-gray-700">Handle recursive wildcard expansion (*) for pattern matching in file names.</li>
			<li class="p-2 bg-gray-800 rounded-lg border border-gray-700">Handle Signals (Ctrl+C, Ctrl+D and Ctrl+\).</li>
        </ul>


        <h2 class="text-3xl font-bold text-blue-300 mt-16 mb-6 hero-title">Command Line Parsing</h2>
        <p>
            The initial and most critical phase of the shell is transforming the raw input string into a structured, executable format.
        </p>


        <!-- START MOVED AND REPHRASED SECTION: TOKENIZATION & UNDERSTANDING -->
        <h3 class="text-2xl font-bold text-white mt-8 mb-4">Initial Tokenization and Testing Blueprint</h3>
        <p>
            Before implementing the parser, I needed a complete understanding of how Bash tokenizes complex command lines. I created the visualization below as a rigorous testing blueprint in Bash. This systematic analysis of distinct command scenarios served as the crucial pre-development stage.
        </p>

        <!-- Diagram section remains here, before Data Structure Choice -->
        <div class="mb-12 rounded-lg overflow-hidden shadow-2xl border border-gray-700 bg-gray-800 p-4">
            <h4 class="text-xl font-bold text-white mb-4">Tokenization and Structural Mapping</h4>
            <img src="../images/minishell_command_decomposition.png"
                 alt="Diagram showing various commands broken down into structured components: bin, arg, input redir, file descriptors, and pipe."
                 class="w-full h-auto object-cover border border-gray-700 rounded-md mb-4">
            <figcaption class="text-sm text-gray-400 italic">
                Visual representation of different command-line inputs are decomposition, done with Obsidian's canva plug-in.
            </figcaption>
        </div>
        <!-- END MOVED AND REPHRASED SECTION -->


        <h3 class="text-2xl font-bold text-white mt-8 mb-4">Data Structure Choice</h3>
        <p>
            Instead of a complex Abstract Syntax Tree (AST), we chose an array of command structures. This array-based approach significantly simplifies pipeline execution, as each element directly maps to a stage in the command chain (e.g., cmd1 | cmd2), making process forking and piping straightforward.
        </p>

        <h3 class="text-2xl font-bold text-white mt-8 mb-4">The Central Command Structure (`t_cmd`)</h3>
        <p>
            The entire pipeline is built around the primary command structure, which encapsulates all necessary information—binaries to execute a single command.
        </p>

        <div class="bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-700 overflow-x-auto text-sm mb-12">
            <pre class="text-white">
		<span class="text-blue-300">typedef struct s_cmd</span>
		{
			<span class="text-yellow-400">char</span>        *command;       <span class="text-gray-400">// Binary name (e.g., "ls" or "echo")</span>
			<span class="text-yellow-400">char</span>        *path;          <span class="text-gray-400">// Full binary path (e.g., "/bin/ls")</span>
			<span class="text-yellow-400">int</span>         type;           <span class="text-gray-400">// Command type Enum (USER, BUILTIN, or INVALID)</span>
			<span class="text-yellow-400">char</span>        **args;         <span class="text-gray-400">// Argument list (argv equivalent)</span>
			<span class="text-yellow-400">int</span>         arg_amount;     <span class="text-gray-400">// Number of arguments in the command line</span>
			<span class="text-yellow-400">t_redir</span>     *redir;         <span class="text-gray-400">// I/O redirection (path and type)</span>
			<span class="text-yellow-400">int</span>         redir_amount;   <span class="text-gray-400">// Total number of redirections</span>
			<span class="text-yellow-400">int</span>         heredoc_amount; <span class="text-gray-400">// Number of heredoc redirections</span>
			<span class="text-yellow-400">pid_t</span>       pid;            <span class="text-gray-400">// Process ID, used during execution</span>
			<span class="text-yellow-400">t_pipefd</span>    *pipe_in;       <span class="text-gray-400">// int fdes[2] for input pipe redirection</span>
			<span class="text-yellow-400">t_pipefd</span>    *pipe_out;      <span class="text-gray-400">// int fdes[2] for output pipe redirection</span>
			<span class="text-yellow-400">bool</span>        is_directory;   <span class="text-gray-400">// Check if command is a directory (error handling)</span>
			<span class="text-yellow-400">int</span>         error_access;   <span class="text-gray-400">// Error number if any access issue occurs</span>
		} t_cmd;
		</pre>
        </div>

		      <!-- NEW SECTION: CONCRETE PARSING EXAMPLES -->
        <h2 class="text-3xl font-bold text-blue-300 mt-16 mb-6 hero-title">Parsing Examples in Action</h2>
        <p>
            The array-of-structures model proves its efficiency when handling complex command lines that involve multiple pipes (<code class="text-yellow-300">|</code>) and redirections (<code class="text-yellow-300">&lt;</code>, <code class="text-yellow-300">&gt;</code>).
        </p>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <!-- Example 1: Long Pipeline -->
            <div class="command-box">
                <h3 class="text-xl font-bold text-white mb-4">Example 1: Long Pipeline</h3>
                <p class="text-lg font-semibold text-cyan-300 mb-4">
                    <code class="bg-gray-700 p-1 rounded">ls -l | grep "config" | tee configs.txt | wc -l</code>
                </p>
                <div class="text-sm space-y-4">
                    <div class="border-b border-gray-600 pb-2">
                        <span class="font-bold text-blue-400">Command 1: ls</span><br>
                        Path: <span class="text-gray-300">/usr/bin/ls</span><br>
                        Args: <span class="text-gray-300">["ls", "-l"]</span><br>
                        <span class="text-gray-400">Total Args: 2</span> | <span class="text-gray-400">Total Redirections: 0</span>
                    </div>
                    <div class="border-b border-gray-600 pb-2">
                        <span class="font-bold text-blue-400">Command 2: grep</span><br>
                        Path: <span class="text-gray-300">/usr/bin/grep</span><br>
                        Args: <span class="text-gray-300">["grep", "config"]</span><br>
                        <span class="text-gray-400">Total Args: 2</span> | <span class="text-gray-400">Total Redirections: 0</span>
                    </div>
                    <div class="border-b border-gray-600 pb-2">
                        <span class="font-bold text-blue-400">Command 3: tee</span><br>
                        Path: <span class="text-gray-300">/usr/bin/tee</span><br>
                        Args: <span class="text-gray-300">["tee", "configs.txt"]</span><br>
                        <span class="text-gray-400">Total Args: 2</span> | <span class="text-gray-400">Total Redirections: 0</span>
                    </div>
                    <div>
                        <span class="font-bold text-blue-400">Command 4: wc</span><br>
                        Path: <span class="text-gray-300">/usr/bin/wc</span><br>
                        Args: <span class="text-gray-300">["wc", "-l"]</span><br>
                        <span class="text-gray-400">Total Args: 2</span> | <span class="text-gray-400">Total Redirections: 0</span>
                    </div>
                </div>
                <p class="text-xs italic text-gray-500 mt-4">
                    Each command is an individual <code class="text-blue-400">t_cmd</code> structure. The shell's execution automatically handles the necessary pipes to connect their input/output streams.
                </p>
            </div>

            <!-- Example 2: Redirection and Pipes -->
            <div class="command-box">
                <h3 class="text-xl font-bold text-white mb-4">Example 2: Redirection & Pipes</h3>
                <p class="text-lg font-semibold text-cyan-300 mb-4">
                    <code class="bg-gray-700 p-1 rounded">&lt; infile.txt grep a1 | wc -w &gt; outfile.txt</code>
                </p>
                <div class="text-sm space-y-4">
                    <div class="border-b border-gray-600 pb-2">
                        <span class="font-bold text-blue-400">Command 1: grep</span><br>
                        Path: <span class="text-gray-300">/usr/bin/grep</span><br>
                        Args: <span class="text-gray-300">["grep", "a1"]</span><br>
                        <span class="text-gray-400">Total Args: 2</span><br>
                        <span class="text-red-400">Redir[0]: infile.txt (IN REDIR)</span>
                    </div>
                    <div>
                        <span class="font-bold text-blue-400">Command 2: wc</span><br>
                        Path: <span class="text-gray-300">/usr/bin/wc</span><br>
                        Args: <span class="text-gray-300">["wc", "-w"]</span><br>
                        <span class="text-gray-400">Total Args: 2</span><br>
                        <span class="text-green-400">Redir[0]: outfile.txt (OUT REDIR)</span>
                    </div>
                </div>
                <p class="text-xs italic text-gray-500 mt-4">
                    The initial command reads from a file, the output pipes to the second command, and the second command's final output is redirected to a new file.
                </p>
            </div>
        </div>


      <!-- NEW SECTION: QUOTE AND VARIABLE EXPANSION (Rewritten) -->
        <h2 class="text-3xl font-bold text-blue-300 mt-16 mb-6 hero-title">Quote and Variable Expansion</h2>
        <p>
            One of the subtle complexities of shell programming is mastering the rules for <b>single quotes</b> (<code class="text-yellow-300">'</code>), <b>double quotes</b> (<code class="text-yellow-300">"</code>), and <b>variable expansion</b> (<code class="text-yellow-300">$</code>).
        </p>

        <p>
            Our core challenge was ensuring the shell behaves exactly like Bash:
            <ul class="list-disc list-inside space-y-2 pl-4 text-gray-300 mt-4 mb-4">
                <li><strong class="text-yellow-400">Double Quotes (" "):</strong> Allow environment variables (like <code class="bg-gray-700 p-0.5 rounded">$PATH</code> or <code class="bg-gray-700 p-0.5 rounded">$USER</code>) to be replaced (expanded) with their actual values.</li>
                <li><strong class="text-yellow-400">Single Quotes (' '):</strong> Treat everything inside literally. No expansion is performed. The dollar sign ($) is treated as a regular character.</li>
            </ul>
        </p>

        <!-- Placeholder for the Minishell vs Bash Screenshot -->
        <div class="mb-12 rounded-lg overflow-hidden shadow-2xl border border-gray-700 bg-gray-800 p-4">
            <h3 class="text-xl font-bold text-white mb-4">Minishell vs. Bash Comparison</h3>
            <img src="../images/minishell_quote.png"
                 alt="Comparison of Minishell and Bash output for a command containing single and double quotes."
                 class="w-full h-auto object-cover border border-gray-700 rounded-md mb-4">
            <figcaption class="text-sm text-gray-400 italic">
                A side-by-side comparison of a complex <code class="text-yellow-300">echo</code> command executed in Minishell Versus Bash.
            </figcaption>
        </div>

     <!-- NEW SECTION: EXECUTION -->
        <h2 class="text-3xl font-bold text-blue-300 mt-16 mb-6 hero-title">The Execution Phase: Fork, Pipe, and Execve</h2>
        <p>
            This phase is responsible for correctly running user-defined binaries and built-in commands, managing I/O redirection, and handling pipelines.
        </p>

        <h3 class="text-2xl font-bold text-white mt-8 mb-4">Process Management</h3>
        <p>
            To run any external command (a non-built-in like <code class="text-yellow-300">/bin/ls</code>), the shell uses a two-step approach:
        </p>
        <ol class="list-decimal list-inside space-y-2 pl-4 text-gray-300">
            <li><strong class="text-cyan-300">fork():</strong> The parent shell process calls <code class="bg-gray-700 p-0.5 rounded">fork()</code> to create an exact copy of itself (the child process) in order to create a new process for the command.</li>
            <li><strong class="text-cyan-300">execve():</strong> Inside the child process, <code class="bg-gray-700 p-0.5 rounded">execve()</code> is called. This function replaces the running program, hence the necessity of fork().</li>
        </ol>


		<div class="bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-700 overflow-x-auto text-sm my-6">
            <pre class="text-white">
<span class="text-gray-400">// char *cmd.path = "/bin/ls"</span>
<span class="text-gray-400">// char **cmd.args = {"ls", "-l", NULL}</span>
<span class="text-gray-400">// char **env = {"PATH=...", "USER=...", NULL}</span>

<span class="text-yellow-400">execve</span>(cmd.path, cmd.args, env) == <span class="text-red-400">-1</span>
</pre>
        </div>


        <p>
            The parent shell then waits for the child process to terminate, retrieves its exit status that will be expandable using "<code class="text-yellow-300">$?</code>".
        </p>

        <h3 class="text-2xl font-bold text-white mt-8 mb-4">Handling Pipelines with pipe()</h3>
        <p>
            Pipelines (<code class="text-yellow-300">cmd1 | cmd2</code>) introduce a layer of complexity known as Inter-Process Communication (IPC). The shell uses the <code class="bg-gray-700 p-0.5 rounded">pipe()</code> system call to create a connection between the standard output (stdout) of the first command and the standard input (stdin) of the second.
        </p>
        <p>
            For a sequence of commands, the process involves:
        </p>
        <ul class="list-disc list-inside space-y-2 pl-4 text-gray-300">
            <li>Before <code class="text-yellow-300">execve()</code> is called in the child process, the file descriptors for stdin and/or stdout are redirected using <code class="bg-gray-700 p-0.5 rounded">dup2()</code>.</li>
            <li>For the first command in the pipe, stdout is pointed to the write-end of the pipe.</li>
            <li>For the second command, stdin is pointed to the read-end of the pipe.</li>
            <li>The child process executes its command, and any output automatically flows through the pipe to the next process's input, completing the chain.</li>
        </ul>
        <p>
            This meticulous orchestration of <code class="text-yellow-300">fork()</code>, <code class="text-yellow-300">pipe()</code>, and file descriptor manipulation is crucial for the shell's ability to run complex chained commands efficiently.
        </p>



    </main>

    <!-- FOOTER -->
    <footer class="mt-20 py-6 border-t border-gray-700 text-center text-sm text-gray-500">
        <!-- Footer text remains unchanged -->
        <p>&copy; 2025 Alexandre Van Der Plassche.</p>
    </footer>

</body>
</html>